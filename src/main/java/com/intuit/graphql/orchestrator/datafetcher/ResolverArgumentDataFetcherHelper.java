package com.intuit.graphql.orchestrator.datafetcher;

import static com.intuit.graphql.orchestrator.utils.GraphQLUtil.createTypeBasedOnGraphQLType;
import static java.util.Collections.singletonList;

import com.intuit.graphql.orchestrator.resolverdirective.ResolverArgumentDirective;
import graphql.VisibleForTesting;
import graphql.analysis.QueryTransformer;
import graphql.execution.DataFetcherResult;
import graphql.execution.ExecutionStepInfo;
import graphql.execution.MergedField;
import graphql.language.Argument;
import graphql.language.Field;
import graphql.language.OperationDefinition;
import graphql.language.VariableDefinition;
import graphql.language.VariableReference;
import graphql.schema.DataFetchingEnvironment;
import graphql.schema.DataFetchingEnvironmentImpl;
import graphql.schema.GraphQLObjectType;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;
import lombok.Getter;

/**
 * This class helps break up the ResolverArgumentDataFetcher class and it contains logic to fetch data requested by the
 * data fetcher. This class is responsible for modifying the DataFetchingEnvironment so that the batch loader is able to
 * correctly call the downstream services with argument data.
 */
@Getter
public class ResolverArgumentDataFetcherHelper {

  private final String namespace;

  private static final String VARIABLE_REFERENCE_FORMAT = "%s_%s";

  @VisibleForTesting
  static final ExecutionStepInfoModifier executionStepInfoModifier = new ExecutionStepInfoModifier();

  public ResolverArgumentDataFetcherHelper(String namespace) {
    this.namespace = namespace;
  }

  /**
   * Modifies the provided DataFetchingEnvironment by attaching arguments, variable definitions, and variable references
   * to objects in the environment that need them.
   *
   * Rebuilding the DataFetchingEnvironment relies on APIs that are marked with @Internal in GraphQL-Java. The stability
   * of this code depends on changes of the DataFetchingEnvironmentImpl.
   *
   * Note that only the ExecutionStepInfo is used to build the query in the QueryExecutorBatchLoader, but a majority of
   * the fields must change to achieve consistency for the most commonly used getters (field, mergedField, etc.)
   *
   * Below are the fields in the DataFetchingEnvironment that are changed:
   *
   * executionStepInfo: QueryExecutorBatchLoader extracts field information from the root ExecutionStepInfo. Arguments
   * must be injected into each level.
   *
   * arguments: Add argument data
   *
   * mergedField: Add list of arguments to the mergedField
   *
   * operationDefinition: Adds a new list of variable definitions generated by this method to the operationDefinition
   *
   * @param env a data fetching environment that will accept arguments
   * @param resolvedArgumentData argument data that should be bound to the data fetching environment
   * @return A DataFetcherResult with the value
   */
  public CompletableFuture<DataFetcherResult<Object>> callBatchLoaderWithArguments(DataFetchingEnvironment env,
      Map<ResolverArgumentDirective, Object> resolvedArgumentData) {

    Map<String, Object> variables = new HashMap<>();
    List<VariableDefinition> variableDefinitions = new ArrayList<>();
    List<Argument> fieldArguments = new ArrayList<>();

    int uniqueIdentifier = 0;

    for (final Entry<ResolverArgumentDirective, Object> entry : resolvedArgumentData.entrySet()) {
      final ResolverArgumentDirective resolverArgumentDirective = entry.getKey();
      final Object argumentData = entry.getValue();

      //add inc to make argument globally unique
      String variableBinding = String
          .format(VARIABLE_REFERENCE_FORMAT, resolverArgumentDirective.getArgumentName(), uniqueIdentifier++);

      variables.put(variableBinding, argumentData);

      variableDefinitions.add(VariableDefinition.newVariableDefinition()
          .name(variableBinding)
          .type(createTypeBasedOnGraphQLType(resolverArgumentDirective.getInputType()))
          .build());

      fieldArguments.add(Argument.newArgument()
          .name(resolverArgumentDirective.getArgumentName())
          .value(VariableReference.newVariableReference()
              .name(variableBinding)
              .build())
          .build());
    }

    final OperationDefinition queryOperation = env.getOperationDefinition();

    // the old code was to transform env.getMergedField() which basically
    // replaces the list of fields.  In graphql-java 16.2., MergedBuild builder adds
    // compared to < 15.0 which replaces the field list.
    final MergedField newMergedField = MergedField
        .newMergedField(singletonList(env.getField()
            .transform(fieldBuilder -> fieldBuilder.arguments(fieldArguments))))
        .build();

    final OperationDefinition opDefWithVariables = queryOperation
        .transform(builder -> builder.variableDefinitions(variableDefinitions));

    Map<String, Object> dfeArguments = resolvedArgumentData.entrySet()
        .stream()
        .collect(Collectors.toMap(entry -> entry.getKey().getArgumentName(), Entry::getValue));

    DataFetchingEnvironment dfeWithArgs = DataFetchingEnvironmentImpl
        .newDataFetchingEnvironment(env)
        .operationDefinition(opDefWithVariables)
        .executionStepInfo(executionStepInfoModifier.addArgumentsToExecutionStepInfo(env, fieldArguments))
        .mergedField(newMergedField)
        .variables(variables)
        .arguments(dfeArguments)
        .build();

    return dfeWithArgs.<DataFetchingEnvironment, DataFetcherResult<Object>>getDataLoader(namespace).load(dfeWithArgs);
  }


  /**
   * This class is responsible for modifying an ExecutionStepInfo by adding arguments to every Field or Argument
   * reference in the StepInfo.
   */
  static class ExecutionStepInfoModifier {

    @VisibleForTesting
    static final FieldArgumentModifier fieldArgumentModifier = new FieldArgumentModifier();

    private ExecutionStepInfo addArguments(ExecutionStepInfo executionStepInfo, String expectedContainerName,
        String expectedFieldName, DataFetchingEnvironment env, List<Argument> arguments,
        Map<String, Object> argumentsAsMap) {
      if (executionStepInfo == null) {
        return null;
      }

      Field fieldToTransform = Optional.of(executionStepInfo)
          .map(ExecutionStepInfo::getField)
          .map(MergedField::getSingleField)
          .orElse(null);

      if (fieldToTransform == null) {
        return executionStepInfo;
      }

      Field newField = fieldArgumentModifier
          .appendArgumentsToField(fieldToTransform, executionStepInfo.getFieldContainer(), expectedContainerName,
              expectedFieldName, env, arguments);

      return executionStepInfo.transform(builder -> builder.field(MergedField.newMergedField(newField).build())
          .arguments(argumentsAsMap)
          .parentInfo(
              addArguments(executionStepInfo.getParent(), expectedContainerName, expectedFieldName, env, arguments,
                  argumentsAsMap)));
    }

    public ExecutionStepInfo addArgumentsToExecutionStepInfo(DataFetchingEnvironment env, List<Argument> arguments) {
      final ExecutionStepInfo executionStepInfo = env.getExecutionStepInfo();

      String expectedContainerName = executionStepInfo.getFieldContainer().getName();
      String expectedFieldName = executionStepInfo.getField().getName();

      Map<String, Object> stepInfoArguments = arguments.stream()
          .collect(Collectors.toMap(Argument::getName, Argument::getValue));

      return addArguments(executionStepInfo, expectedContainerName, expectedFieldName, env, arguments,
          stepInfoArguments);
    }
  }

  static class FieldArgumentModifier {

    /**
     * Adds arguments to the {@code field}
     *
     * @param field the field that contains subfields that require arguments
     * @param fieldContainer the GraphQLObjectType where the field exists
     * @param expectedFieldContainer the GraphQLObjectType where the field that needs to be modified exists (could also
     * be fieldContainer)
     * @param env a DataFetchingEnvironment
     * @param arguments arguments that should be appended to the field or subfield
     * @return a modified field wherein a selection set within that field is modified with the provided arguments
     */
    public Field appendArgumentsToField(Field field, GraphQLObjectType fieldContainer, String expectedFieldContainer,
        String expectedFieldName,
        DataFetchingEnvironment env, List<Argument> arguments) {
      ArgumentAppenderVisitor visitor = new ArgumentAppenderVisitor(expectedFieldContainer, expectedFieldName,
          arguments);

      QueryTransformer fieldTransformer = QueryTransformer.newQueryTransformer()
          .root(field)
          .fragmentsByName(env.getFragmentsByName())
          .rootParentType(fieldContainer)
          .schema(env.getGraphQLSchema())
          .variables(env.getVariables())
          .build();

      return (Field) fieldTransformer.transform(visitor);
    }
  }

}
