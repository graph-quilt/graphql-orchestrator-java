{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"GraphQL Orchestrator \u00b6 Introduction \u00b6 Unlike REST, GraphQL follows a single endpoint model wherein, the client is expected to call one endpoint to get all its data. A large organization typically consists of numerous microservices that are owned by different teams. This leads to a need for a GraphQL orchestrator that provides a single graphql endpoint orchestrating data across multiple graphql providers. GraphQL Orchestrator is a library that exposes data from various data providers using a single unified GraphQL schema. It aggregates and combines the schemas from these data providers and orchestrates the incoming graphql queries to the appropriate services. It uses the graphql-java library as the runtime execution engine on the unified schema. It provides the following features Recursive schema stitching Parallel network calls to Data Providers Batching queries \u00a9 Copyright 2021 Intuit Inc.","title":"Home"},{"location":"#graphql-orchestrator","text":"","title":"GraphQL Orchestrator"},{"location":"#introduction","text":"Unlike REST, GraphQL follows a single endpoint model wherein, the client is expected to call one endpoint to get all its data. A large organization typically consists of numerous microservices that are owned by different teams. This leads to a need for a GraphQL orchestrator that provides a single graphql endpoint orchestrating data across multiple graphql providers. GraphQL Orchestrator is a library that exposes data from various data providers using a single unified GraphQL schema. It aggregates and combines the schemas from these data providers and orchestrates the incoming graphql queries to the appropriate services. It uses the graphql-java library as the runtime execution engine on the unified schema. It provides the following features Recursive schema stitching Parallel network calls to Data Providers Batching queries \u00a9 Copyright 2021 Intuit Inc.","title":"Introduction"},{"location":"key-concepts/algorithm/","text":"High Level Algorithm \u00b6 The orchestrator merges the schema using a very simple merging algorithm. It uses Xtext to parse the schema files into an Abstract Syntax Tree(AST) representation. The Xtext internally uses Antlr, but provides some additional features like cross-referencing, custom validations, etc. that has been very helpful to operate on the graph. The Algorithm consists of 3 phases - Pre-Merge Transformers \u00b6 This phase consists of performing a set of transformations to the individual providers schemas. Such transformations enrich the xtext AST. Some examples include attaching namespace to the description of all the types of the provider, marking if the schema contains union or interfaces etc. The top level fields inside Query type are also marked with appropriate DataFetcher context to prepare the graphql-java code registry. Merging \u00b6 The individual schemas are merged to form a single unified schema using a recursive strategy . The output is a Xtext AST that can further be enriched by applying post merge transformations. During this phase, the graphql-java code registry is also modified as per the strategy. Post-Merge Transformers \u00b6 The post merge transformers applies to the final unified schema. One such transformation converts the Xtext AST to an executable GraphQLSchema which can be used to execute GraphQL queries on the orchestrator. \u00a9 Copyright 2021 Intuit Inc.","title":"High Level Algorithm"},{"location":"key-concepts/algorithm/#high-level-algorithm","text":"The orchestrator merges the schema using a very simple merging algorithm. It uses Xtext to parse the schema files into an Abstract Syntax Tree(AST) representation. The Xtext internally uses Antlr, but provides some additional features like cross-referencing, custom validations, etc. that has been very helpful to operate on the graph. The Algorithm consists of 3 phases -","title":"High Level Algorithm"},{"location":"key-concepts/algorithm/#pre-merge-transformers","text":"This phase consists of performing a set of transformations to the individual providers schemas. Such transformations enrich the xtext AST. Some examples include attaching namespace to the description of all the types of the provider, marking if the schema contains union or interfaces etc. The top level fields inside Query type are also marked with appropriate DataFetcher context to prepare the graphql-java code registry.","title":"Pre-Merge Transformers"},{"location":"key-concepts/algorithm/#merging","text":"The individual schemas are merged to form a single unified schema using a recursive strategy . The output is a Xtext AST that can further be enriched by applying post merge transformations. During this phase, the graphql-java code registry is also modified as per the strategy.","title":"Merging"},{"location":"key-concepts/algorithm/#post-merge-transformers","text":"The post merge transformers applies to the final unified schema. One such transformation converts the Xtext AST to an executable GraphQLSchema which can be used to execute GraphQL queries on the orchestrator. \u00a9 Copyright 2021 Intuit Inc.","title":"Post-Merge Transformers"},{"location":"key-concepts/conflict-resolution/","text":"Type Conflict Resolution \u00b6 In a distributed GraphQL world, your GraphQL schema is developed, parsed, and validated independently of other GraphQL schemas. Your schema is eventually integrated with other GraphQL schemas in the orchestrator, where we merge and stitch schemas together to produce a single executable schema. The orchestrator performs validations to ensure the merged schema conforms to the GraphQL specification, and ensures that your schema can be correctly merged into the single schema. Your schema could be validated against hundreds of other schemas that already exist in the orchestrator! Thus, how you define your types becomes important because you could be clashing with many different providers all with similar type names and schema structures. With many different providers producing GraphQL types, you are bound to run into collisions when trying to merge schemas together. Resolution Strategies \u00b6 Let's say you have an object-type Profile which is conflicting with the orchestrator. When we say a type conflicts with the orchestrator, it really means that it is conflicting with some other provider that has already registered type Profile . You can contact the provider and discuss the conflicting type with them and see if it qualifies for type extension. But let's say, the type Profile is semantically different from the other providers Profile type. Below are some of the strategies you can use to resolve conflicts. Type Renaming Resolution Strategy \u00b6 Suppose you are a User service trying to expose a Profile type representing a user's profile. type Query { userProfile: Profile } type Profile { userId: ID firstName: String lastName: String age: Int } Looks good on paper, but when you try to integrate with the orchestrator, it rejects your schema because Profile is conflicting with another type Profile defined by another service! type Query { financialProfile: Profile } type Profile { income: Float debt: Float } How do we fix this? Be as specific as possible when building your schema types. For example, a Profile type can be made more specific by answering the following questions: What specific profile is this (Finance, User)? Does your type belong to a specific product (TurboTax, Mint)? The results of answering the questions above and applying it to the Profile type could be: TurboTaxUserProfile MintUserProfile @rename Directive Resolution Strategy \u00b6 This resolution strategy is useful for initial on-boarding purposes where you have clients that already call your service's GraphQL endpoint, but you need to rename conflicting types in order to register with the orchestrator. Suppose that you need to change your Profile type to TurboTaxUserProfile . However, you have existing clients that query your profile with fragments and fragment definitions which require the actual type name: query { profile { ...userProfile } } fragment userProfile on Profile { userId firstName lastName } You cannot rename the type Profile to something else because the new type will cause the queries of existing clients with these fragments to fail! How do we fix this? With @rename directive, you can expose type Profile in your service (and accept queries that specify the Profile type), but expose that type as something else through the orchestrator. For example, an introspection on your service would yield Profile , but an introspection on the orchestrator would yield Finance_Profile type Query { financialProfile: Profile } type Profile @rename(to: \"Financial_Profile\"){ income: Float debt: Float } In the example configuration below, types Profile will become Financial_Profile in the orchestrator schema, but will remain Profile in your service. Subsequently, at runtime, when the orchestrator calls your service to resolve Financial_Profile , the namespace information will be stripped away, and your service will receive queries for Profile . Field Conflict Resolution \u00b6 When the number of providers increase, you might run into a scenario where 2 providers provide the same field names. To get past it, you can use the @rename directive at the field level and resolve such field level naming conflicts.","title":"Conflict Resolution"},{"location":"key-concepts/conflict-resolution/#type-conflict-resolution","text":"In a distributed GraphQL world, your GraphQL schema is developed, parsed, and validated independently of other GraphQL schemas. Your schema is eventually integrated with other GraphQL schemas in the orchestrator, where we merge and stitch schemas together to produce a single executable schema. The orchestrator performs validations to ensure the merged schema conforms to the GraphQL specification, and ensures that your schema can be correctly merged into the single schema. Your schema could be validated against hundreds of other schemas that already exist in the orchestrator! Thus, how you define your types becomes important because you could be clashing with many different providers all with similar type names and schema structures. With many different providers producing GraphQL types, you are bound to run into collisions when trying to merge schemas together.","title":"Type Conflict Resolution"},{"location":"key-concepts/conflict-resolution/#resolution-strategies","text":"Let's say you have an object-type Profile which is conflicting with the orchestrator. When we say a type conflicts with the orchestrator, it really means that it is conflicting with some other provider that has already registered type Profile . You can contact the provider and discuss the conflicting type with them and see if it qualifies for type extension. But let's say, the type Profile is semantically different from the other providers Profile type. Below are some of the strategies you can use to resolve conflicts.","title":"Resolution Strategies"},{"location":"key-concepts/conflict-resolution/#type-renaming-resolution-strategy","text":"Suppose you are a User service trying to expose a Profile type representing a user's profile. type Query { userProfile: Profile } type Profile { userId: ID firstName: String lastName: String age: Int } Looks good on paper, but when you try to integrate with the orchestrator, it rejects your schema because Profile is conflicting with another type Profile defined by another service! type Query { financialProfile: Profile } type Profile { income: Float debt: Float } How do we fix this? Be as specific as possible when building your schema types. For example, a Profile type can be made more specific by answering the following questions: What specific profile is this (Finance, User)? Does your type belong to a specific product (TurboTax, Mint)? The results of answering the questions above and applying it to the Profile type could be: TurboTaxUserProfile MintUserProfile","title":"Type Renaming Resolution Strategy"},{"location":"key-concepts/conflict-resolution/#rename-directive-resolution-strategy","text":"This resolution strategy is useful for initial on-boarding purposes where you have clients that already call your service's GraphQL endpoint, but you need to rename conflicting types in order to register with the orchestrator. Suppose that you need to change your Profile type to TurboTaxUserProfile . However, you have existing clients that query your profile with fragments and fragment definitions which require the actual type name: query { profile { ...userProfile } } fragment userProfile on Profile { userId firstName lastName } You cannot rename the type Profile to something else because the new type will cause the queries of existing clients with these fragments to fail! How do we fix this? With @rename directive, you can expose type Profile in your service (and accept queries that specify the Profile type), but expose that type as something else through the orchestrator. For example, an introspection on your service would yield Profile , but an introspection on the orchestrator would yield Finance_Profile type Query { financialProfile: Profile } type Profile @rename(to: \"Financial_Profile\"){ income: Float debt: Float } In the example configuration below, types Profile will become Financial_Profile in the orchestrator schema, but will remain Profile in your service. Subsequently, at runtime, when the orchestrator calls your service to resolve Financial_Profile , the namespace information will be stripped away, and your service will receive queries for Profile .","title":"@rename Directive Resolution Strategy"},{"location":"key-concepts/conflict-resolution/#field-conflict-resolution","text":"When the number of providers increase, you might run into a scenario where 2 providers provide the same field names. To get past it, you can use the @rename directive at the field level and resolve such field level naming conflicts.","title":"Field Conflict Resolution"},{"location":"key-concepts/field-links/","text":"Field Links \u00b6 Overview \u00b6 There will be instances where data from different Service Providers are related, like how tables are related in relational databases. As an example, let\u2019s look at these GraphQL Schemas from two different services: Prediction Service type Query { topThreeCustomers: [RatedCustomer] } type RatedCustomer { customerId: String ratingResult: Int } Customer Service type Query { customerById(id: String): Customer } type Customer { id: String name: String } The problem \u00b6 Let\u2019s say an Application wants to display the top three customers including the name of each customer. There will be several calls to GraphQL Orchestrator: Query prediction service: query { topThreeCustomers: { customerId ratingResult } } Query customer service for each rated customer: customerById(id: $CustomerId) The application needs multiple calls and defeats the purpose of having a single call to a graphql endpoint. Solution \u00b6 extend type RatedCustomer { # $customerId is a reference to a sibling field customerInfo : Customer @resolver(field: \"customerById\" arguments: [{name : \"id\", value: \"$customerId\"}]) } @resolver directive section further explains each element in detail. With the extended RatedCustomer type, the application can make SINGLE CALL to achieve the objective: query { topThreeCustomers: { customerId ratingResult customerInfo: { name } } } Can you guess what happen under the hood? For field topThreeCustomers , orchestrator will call the Prediction Service first which shall return a list of RatedCustomer Then it will resolve topThreeCustomers.customerInfo by executing the @resolver directive which basically calls the Customer Service passing the value of $customerId . Even if the list is of size 3, the orchestrator will only make one call to the Customer Service and batch the list together using an alias as shown below query { id0_O: customerInfo: { name } id01_1: customerInfo: { name } id02_2: customerInfo: { name } } @resolver directive \u00b6 resolver directive on field definition defines how to resolve a field that belongs to a different provider.","title":"Remote Type Extensions"},{"location":"key-concepts/field-links/#field-links","text":"","title":"Field Links"},{"location":"key-concepts/field-links/#overview","text":"There will be instances where data from different Service Providers are related, like how tables are related in relational databases. As an example, let\u2019s look at these GraphQL Schemas from two different services: Prediction Service type Query { topThreeCustomers: [RatedCustomer] } type RatedCustomer { customerId: String ratingResult: Int } Customer Service type Query { customerById(id: String): Customer } type Customer { id: String name: String }","title":"Overview"},{"location":"key-concepts/field-links/#the-problem","text":"Let\u2019s say an Application wants to display the top three customers including the name of each customer. There will be several calls to GraphQL Orchestrator: Query prediction service: query { topThreeCustomers: { customerId ratingResult } } Query customer service for each rated customer: customerById(id: $CustomerId) The application needs multiple calls and defeats the purpose of having a single call to a graphql endpoint.","title":"The problem"},{"location":"key-concepts/field-links/#solution","text":"extend type RatedCustomer { # $customerId is a reference to a sibling field customerInfo : Customer @resolver(field: \"customerById\" arguments: [{name : \"id\", value: \"$customerId\"}]) } @resolver directive section further explains each element in detail. With the extended RatedCustomer type, the application can make SINGLE CALL to achieve the objective: query { topThreeCustomers: { customerId ratingResult customerInfo: { name } } } Can you guess what happen under the hood? For field topThreeCustomers , orchestrator will call the Prediction Service first which shall return a list of RatedCustomer Then it will resolve topThreeCustomers.customerInfo by executing the @resolver directive which basically calls the Customer Service passing the value of $customerId . Even if the list is of size 3, the orchestrator will only make one call to the Customer Service and batch the list together using an alias as shown below query { id0_O: customerInfo: { name } id01_1: customerInfo: { name } id02_2: customerInfo: { name } }","title":"Solution"},{"location":"key-concepts/field-links/#resolver-directive","text":"resolver directive on field definition defines how to resolve a field that belongs to a different provider.","title":"@resolver directive"},{"location":"key-concepts/graphql-query-execution/","text":"GraphQL Query Execution \u00b6 GraphQL Orchestrator uses the graphql-java library for query execution at runtime. In this section, we will discuss how the Orchestrator breaks up an incoming query into multiple sub-queries to be sent to their respective service providers. Deconstructing your query | Rebuilding the response \u00b6 GraphQL Orchestrator partitions a query into sub-queries, so that downstream services only get queries for the schema that they operate on. Given a scenario, imagine that query.person/spouse.firstName are served by NameService, and query.person/spouse.address.city is served by Address. Here is a query that requests for both pieces of information: query { person { firstName address { city } } spouse { firstName address { city } } } GraphQL Orchestrator will split this query into two subqueries and call the appropriate providers in parallel: query { person { firstname } spouse { firstname } } query { person { address { ciy } } spouse { address { ciy } } } Note that GraphQL Orchestrator will preserve the query hierarchy no matter how deep it must traverse to split the query. After retrieving the individual responses from separate services, the orchestrator combines both GraphQL errors and data into a single response for the client. Batching queries \u00b6 Even though the firstName field is at a different level for person and spouse, they belong to the same provider. The GraphQL Orchestrator will make sure that the fields that belong to the NameService provider as batched together before calling the provider. In simple words, the GraphQL Orchestrator will make sure that the downstream provider is only called once per request, regardless of the schema hierarchy. \u00a9 Copyright 2021 Intuit Inc.","title":"GraphQL Query Execution"},{"location":"key-concepts/graphql-query-execution/#graphql-query-execution","text":"GraphQL Orchestrator uses the graphql-java library for query execution at runtime. In this section, we will discuss how the Orchestrator breaks up an incoming query into multiple sub-queries to be sent to their respective service providers.","title":"GraphQL Query Execution"},{"location":"key-concepts/graphql-query-execution/#deconstructing-your-query-rebuilding-the-response","text":"GraphQL Orchestrator partitions a query into sub-queries, so that downstream services only get queries for the schema that they operate on. Given a scenario, imagine that query.person/spouse.firstName are served by NameService, and query.person/spouse.address.city is served by Address. Here is a query that requests for both pieces of information: query { person { firstName address { city } } spouse { firstName address { city } } } GraphQL Orchestrator will split this query into two subqueries and call the appropriate providers in parallel: query { person { firstname } spouse { firstname } } query { person { address { ciy } } spouse { address { ciy } } } Note that GraphQL Orchestrator will preserve the query hierarchy no matter how deep it must traverse to split the query. After retrieving the individual responses from separate services, the orchestrator combines both GraphQL errors and data into a single response for the client.","title":"Deconstructing your query | Rebuilding the response"},{"location":"key-concepts/graphql-query-execution/#batching-queries","text":"Even though the firstName field is at a different level for person and spouse, they belong to the same provider. The GraphQL Orchestrator will make sure that the fields that belong to the NameService provider as batched together before calling the provider. In simple words, the GraphQL Orchestrator will make sure that the downstream provider is only called once per request, regardless of the schema hierarchy. \u00a9 Copyright 2021 Intuit Inc.","title":"Batching queries"},{"location":"key-concepts/interface-union-types/","text":"Interface or Union Types \u00b6 An interface is an abstract type that includes a certain set of fields that a type must include. interface Pet { id: ID! } type Dog implements Pet { id: ID! price: Int } type Cat implements Pet { id: ID! livesLeft: Int! } Union types are very similar to interfaces, but they don't get to specify any common fields between the types. type Dog { name: String price: Int } type Cat { id: ID livesLeft: Int! } union Pet = Dog | Cat Learn more on interface and union, Problem \u00b6 When the provider has a field that returns a Pet(union or interface) type in the schema, the result can be of type Dog or Cat. The graphql provider serving the Pet type needs to implement a type-resolver to resolve Pet to either Cat or Dog at query execution time. When the graphql provider registers with the orchestrator, the orchestrator gets the types Pet, Cat, and Dog, but does not have any information about the business logic of the type resolver. Solution \u00b6 The orchestrator handles such fields by implementing a generic type resolver using the introspection field __typename . It transforms the incoming query by adding the field __typename so that the provider returns the type name. Let's take an example query made by the client to the orchestrator for the interface Pet query { allPets { id ... on Dog { price } ... on Cat { livesLeft } } } The query that the orchestrator makes to the Pet provider looks like query { allPets { __typename id ... on Dog { price } ... on Cat { livesLeft } } } \u00a9 Copyright 2021 Intuit Inc.","title":"Handling Interfaces and Unions"},{"location":"key-concepts/interface-union-types/#interface-or-union-types","text":"An interface is an abstract type that includes a certain set of fields that a type must include. interface Pet { id: ID! } type Dog implements Pet { id: ID! price: Int } type Cat implements Pet { id: ID! livesLeft: Int! } Union types are very similar to interfaces, but they don't get to specify any common fields between the types. type Dog { name: String price: Int } type Cat { id: ID livesLeft: Int! } union Pet = Dog | Cat Learn more on interface and union,","title":"Interface or Union Types"},{"location":"key-concepts/interface-union-types/#problem","text":"When the provider has a field that returns a Pet(union or interface) type in the schema, the result can be of type Dog or Cat. The graphql provider serving the Pet type needs to implement a type-resolver to resolve Pet to either Cat or Dog at query execution time. When the graphql provider registers with the orchestrator, the orchestrator gets the types Pet, Cat, and Dog, but does not have any information about the business logic of the type resolver.","title":"Problem"},{"location":"key-concepts/interface-union-types/#solution","text":"The orchestrator handles such fields by implementing a generic type resolver using the introspection field __typename . It transforms the incoming query by adding the field __typename so that the provider returns the type name. Let's take an example query made by the client to the orchestrator for the interface Pet query { allPets { id ... on Dog { price } ... on Cat { livesLeft } } } The query that the orchestrator makes to the Pet provider looks like query { allPets { __typename id ... on Dog { price } ... on Cat { livesLeft } } } \u00a9 Copyright 2021 Intuit Inc.","title":"Solution"},{"location":"key-concepts/merging-types/","text":"Recursive Schema Stitching \u00b6 Operation type merging \u00b6 GraphQL Orchestrator combines schema from multiple data providers into a unified schema at runtime. When a data consumer makes a graphql query to the orchestrator, the orchestrator is able to split the query to appropriate providers, execute the query and combine the results accurately. The orchestrator performs recursive merging of types using the stitching algorithm. Take an example of two providers: Pet Service type Query { allPets: [PetType] } type PetType{ ... } User Service type Query { user(id: ID!): UserType! } type UserType{ ... } The orchestrator starts the stitching process at the Operation i.e the Query type. It merges the fields of provider 1 with provider 2 and creates the final Query type. type Query { allPets: [PetType] user(id: ID!): UserType! } type UserType { ... } type PetType { ... } Recursive merging \u00b6 Nested Object types are also merged according to the strategy above as long as the field name and the type name matches. Take a look at the example below. Person Name Service type Query { person(id:ID!): PersonType } type PersonType { firstName: String lastName: String } Person Address Service type Query { person(id:ID!): PersonType } type PersonType { address: AddressType } type AddressType {...} GraphQL Orchestrator Schema type Query { person(id:ID!): PersonType } type PersonType { firstName: String lastName: String address: AddressType # address type is merged } type AddressType {...} In the above example, type Person is merged because the field name person , the type name Person and the argument list matches. Directives and Arguments \u00b6 The recursive merging strategy does not apply if the nested type ( PersonType ) being merged has directives. if the nested type ( PersonType ) being merged has different argument name or type. Note: The strategy's sole purpose is to have some structure to the final unified schema so that it is easy to explore. \u00a9 Copyright 2021 Intuit Inc.","title":"Recursive Schema Stitching"},{"location":"key-concepts/merging-types/#recursive-schema-stitching","text":"","title":"Recursive Schema Stitching"},{"location":"key-concepts/merging-types/#operation-type-merging","text":"GraphQL Orchestrator combines schema from multiple data providers into a unified schema at runtime. When a data consumer makes a graphql query to the orchestrator, the orchestrator is able to split the query to appropriate providers, execute the query and combine the results accurately. The orchestrator performs recursive merging of types using the stitching algorithm. Take an example of two providers: Pet Service type Query { allPets: [PetType] } type PetType{ ... } User Service type Query { user(id: ID!): UserType! } type UserType{ ... } The orchestrator starts the stitching process at the Operation i.e the Query type. It merges the fields of provider 1 with provider 2 and creates the final Query type. type Query { allPets: [PetType] user(id: ID!): UserType! } type UserType { ... } type PetType { ... }","title":"Operation type merging"},{"location":"key-concepts/merging-types/#recursive-merging","text":"Nested Object types are also merged according to the strategy above as long as the field name and the type name matches. Take a look at the example below. Person Name Service type Query { person(id:ID!): PersonType } type PersonType { firstName: String lastName: String } Person Address Service type Query { person(id:ID!): PersonType } type PersonType { address: AddressType } type AddressType {...} GraphQL Orchestrator Schema type Query { person(id:ID!): PersonType } type PersonType { firstName: String lastName: String address: AddressType # address type is merged } type AddressType {...} In the above example, type Person is merged because the field name person , the type name Person and the argument list matches.","title":"Recursive merging"},{"location":"key-concepts/merging-types/#directives-and-arguments","text":"The recursive merging strategy does not apply if the nested type ( PersonType ) being merged has directives. if the nested type ( PersonType ) being merged has different argument name or type. Note: The strategy's sole purpose is to have some structure to the final unified schema so that it is easy to explore. \u00a9 Copyright 2021 Intuit Inc.","title":"Directives and Arguments"},{"location":"specifications/custom-directives/","text":"@rename \u00b6 # Directive used to rename a type or field when registration with Data Api directive @rename(to: String!) on FIELD_DEFINITION | OBJECT | INTERFACE See Usage @resolver \u00b6 # @resolver directive definition directive @resolver(field: String, arguments: [ResolverArgument!]) on FIELD_DEFINITION # Input type for @resolver arguments. input ResolverArgument { name : String! value : String! } It defines the target field, its arguments and argument values. Under the hood, this will call the backend service that owns the target field. field \u00b6 This parameter defines the path of the target field. The target field should be owned by a data provider that is already registered in GraphQL Orchestrator. It has the following syntax {rootField}.{childField1}.{childField2}...{targetField} where it forms a path from rootField to targetField. arguments \u00b6 the targetField can have zero or more arguments. This is an array of ResolverArgument where each defines argument name. This should match an argument name of the targetField argument value. The value should conform to Input Values syntax. Examples \u00b6 target field without parameters extend type User { allPets : Pet @resolver ( field : \"allPets\" ) } target field with scalar type argument extend type User { pet : Pet @resolver ( field : \"petById\" arguments : [ {name : \"id\", value: \"$petId\"} ] ) } where $petId is a variable reference to petId field in type User . Note: During execution, parent field will be resolved first. In this example, will call User service. The User object/field will be resolved first before resolving the child fields. Thus guarantees that petId will have value. target field with object argument Let's say that the target field argument is type Query { petById(petId: PetId): Pet } input PetId { id: ID } One can define @resolver like extend type User { petById : Pet @resolver ( field : \"petById\" arguments : [ {name : \"petId\", value: \"{id : \\\"$petId\\\"}\"} ] ) } where $petId is a variable reference to a field of type User See Usage","title":"Custom Directives"},{"location":"specifications/custom-directives/#rename","text":"# Directive used to rename a type or field when registration with Data Api directive @rename(to: String!) on FIELD_DEFINITION | OBJECT | INTERFACE See Usage","title":"@rename"},{"location":"specifications/custom-directives/#resolver","text":"# @resolver directive definition directive @resolver(field: String, arguments: [ResolverArgument!]) on FIELD_DEFINITION # Input type for @resolver arguments. input ResolverArgument { name : String! value : String! } It defines the target field, its arguments and argument values. Under the hood, this will call the backend service that owns the target field.","title":"@resolver"},{"location":"specifications/custom-directives/#field","text":"This parameter defines the path of the target field. The target field should be owned by a data provider that is already registered in GraphQL Orchestrator. It has the following syntax {rootField}.{childField1}.{childField2}...{targetField} where it forms a path from rootField to targetField.","title":"field"},{"location":"specifications/custom-directives/#arguments","text":"the targetField can have zero or more arguments. This is an array of ResolverArgument where each defines argument name. This should match an argument name of the targetField argument value. The value should conform to Input Values syntax.","title":"arguments"},{"location":"specifications/custom-directives/#examples","text":"target field without parameters extend type User { allPets : Pet @resolver ( field : \"allPets\" ) } target field with scalar type argument extend type User { pet : Pet @resolver ( field : \"petById\" arguments : [ {name : \"id\", value: \"$petId\"} ] ) } where $petId is a variable reference to petId field in type User . Note: During execution, parent field will be resolved first. In this example, will call User service. The User object/field will be resolved first before resolving the child fields. Thus guarantees that petId will have value. target field with object argument Let's say that the target field argument is type Query { petById(petId: PetId): Pet } input PetId { id: ID } One can define @resolver like extend type User { petById : Pet @resolver ( field : \"petById\" arguments : [ {name : \"petId\", value: \"{id : \\\"$petId\\\"}\"} ] ) } where $petId is a variable reference to a field of type User See Usage","title":"Examples"}]}